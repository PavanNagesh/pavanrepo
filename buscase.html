<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Cases</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom right, #283c4f, #1a242f);
            color: #eee;
            line-height: 1.6;
            font-size: 1rem;
            overflow-x: hidden;
        }

        .container {
            padding: 40px 8%;
            max-width: 1200px;
            margin: 0 auto;
        }

        h1, h2, h3 {
            color: #64b5f6;
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
        }

        h1 {
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 2rem;
        }

        h2 {
            font-size: 2rem;
            margin-top: 3rem;
            margin-bottom: 1.5rem;
        }

        h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }

        p {
            margin-bottom: 2rem;
            text-align: justify;
        }

        .algorithm {
            margin-bottom: 3rem;
            padding: 2rem;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .city-map {
            text-align: center;
            margin-top: 4rem;
        }

        img {
            max-width: 75%;
            height: auto;
            border-radius: 10px;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.3);
        }

        .implementation-heading {
            color: #bbdefb;
            margin-top: 3rem;
            text-align: center;
            font-size: 1.7rem;
            font-weight: 500;
        }

        .code-container {
            background-color: #282c34;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            overflow-x: auto;
            margin: 1rem auto 3rem;
            max-width: 1200px;
        }

        pre {
            white-space: pre-wrap;
            margin: 0;
            font-size: 14px;
            line-height: 1.3;
            font-family: 'Courier New', monospace;
        }

        .comment { color: #6a9955; }
        .keyword { color: #c678dd; }
        .string { color: #98c379; }
        .number { color: #d19a66; }
        .operator { color: #e06c75; }
        .preprocessor { color: #56b6c2; }
        .type { color: #61afef; }
        .function { color: #e5c07b; }

        .view-code-button {
            display: block;
            padding: 8px 16px;
            background-color: #4CAF50;
            border: none;
            color: white;
            text-align: center;
            text-decoration: none;
            font-size: 14px;
            margin: 10px auto;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.2s;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
        }

        .view-code-button:hover {
            background-color: #45a049;
            transform: scale(1.03);
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
        }

        .view-code-button:active{
            transform: scale(0.97);
            box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Business Cases</h1>

        <h2>Business Case - 1: Emergency Response and Disaster Management</h2>
        <p>In the face of unexpected emergencies and devastating disasters, swift and effective action is paramount. This business case focuses on leveraging advanced algorithms and data management techniques to significantly improve response times and optimize resource allocation during critical events. By implementing intelligent systems that analyze real-time data, predict potential risks, and streamline communication channels, we aim to minimize the impact of disasters and ensure the safety and well-being of affected communities. This involves not only responding to immediate crises but also proactively preparing for future events through data-driven insights and strategic planning. This includes the use of various algorithms to make the whole process efficient and effective.</p>

        <h2>Algorithms and Core Concepts</h2>

        <div class="algorithm">
            <h3>Kruskal's Algorithm</h3>
            <p>Kruskal's algorithm plays a crucial role in establishing efficient communication and logistical networks during emergencies. By finding the minimum spanning tree within a network of potential connections (e.g., roads, communication lines), this algorithm helps determine the most cost-effective way to connect essential locations, such as emergency service centers, hospitals, and evacuation points. This ensures that resources can be deployed quickly and efficiently, minimizing delays and maximizing the impact of relief efforts.</p>
        </div>

        <div class="algorithm">
            <h3>Bellman-Ford Algorithm</h3>
            <p>In emergency response scenarios, time is of the essence. The Bellman-Ford algorithm provides a powerful tool for calculating the shortest paths from a central dispatch point to various incident locations, even in complex and dynamic environments. This algorithm is particularly valuable because it can handle negative edge weights, which can represent factors like time saved due to favorable traffic conditions or the use of specific routes. By accurately determining the fastest routes, emergency responders can reach those in need more quickly, potentially saving lives and minimizing damage.</p>
        </div>

        <div class="algorithm">
            <h3>Quick Sort</h3>
            <p>Effective disaster management relies heavily on the ability to process and analyze large amounts of data quickly and accurately. Quick Sort provides an efficient method for sorting and organizing critical information, such as incident reports, resource availability, and affected population data. This enables emergency responders to quickly identify patterns, prioritize needs, and make informed decisions.</p>
        </div>

        <div class="sdg-section">
            <h3>Applicable SDGs for Emergency Response and Disaster Management</h3>
            <ul>
                <li><strong>SDG 1: No Poverty</strong><br>
                    <em>Reason:</em> Reduces the socio-economic impact of disasters on vulnerable populations, minimizing poverty by protecting lives and livelihoods.<br>
                    <em>Indicators:</em>
                    <ul>
                        <li>1.5.1: Number of deaths, missing persons, and directly affected persons attributed to disasters.</li>
                        <li>1.5.2: Direct economic loss attributed to disasters.</li>
                        <li>1.5.3: Number of countries with national disaster risk reduction strategies.</li>
                    </ul>
                </li>
                <li><strong>SDG 3: Good Health and Well-Being</strong><br>
                    <em>Reason:</em> Enhances emergency preparedness, saves lives, and reduces injuries through optimized response times.<br>
                    <em>Indicators:</em>
                    <ul>
                        <li>3.d.1: International Health Regulations capacity and health emergency preparedness.</li>
                        <li>3.6.1: Death rate due to road traffic injuries.</li>
                    </ul>
                </li>
                <li><strong>SDG 9: Industry, Innovation, and Infrastructure</strong><br>
                    <em>Reason:</em> Strengthens urban and rural transport systems by improving infrastructure resilience and optimizing routes for emergency response.<br>
                    <em>Indicators:</em>
                    <ul>
                        <li>9.1.1: Proportion of the rural population who live within 2 km of an all-season road.</li>
                        <li>9.1.2: Passenger and freight volumes, by mode of transport.</li>
                    </ul>
                </li>
                <li><strong>SDG 11: Sustainable Cities and Communities</strong><br>
                    <em>Reason:</em> Contributes to disaster-resilient cities by reducing casualties, economic loss, and infrastructure damage.<br>
                    <em>Indicators:</em>
                    <ul>
                        <li>11.5.1: Number of deaths, missing persons, and directly affected persons attributed to disasters.</li>
                        <li>11.5.2: Direct economic loss in relation to global GDP, damage to critical infrastructure, and disruption of basic services due to disasters.</li>
                        <li>11.3.1: Ratio of land consumption rate to population growth rate.</li>
                    </ul>
                </li>
                <li><strong>SDG 13: Climate Action</strong><br>
                    <em>Reason:</em> Supports disaster risk reduction, which aligns with mitigating the impacts of climate change-induced disasters.<br>
                    <em>Indicators:</em>
                    <ul>
                        <li>13.1.1: Number of deaths, missing persons, and directly affected persons attributed to disasters per 100,000 population.</li>
                        <li>13.1.2: Number of countries with national and local disaster risk reduction strategies.</li>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="city-map">
            <h2>City Map</h2>
            <img src="./img/fullmap.jpg" alt="City Map">
            <img src="map.png" alt="City Map1">
        </div>

        <div class="implementation-heading">Implementation</div>
        <div class="code-container">
            <pre>
                <span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
                <span class="preprocessor">#include</span> <span class="string">&lt;vector&gt;</span>
                <span class="preprocessor">#include</span> <span class="string">&lt;algorithm&gt;</span>
                <span class="preprocessor">#include</span> <span class="string">&lt;climits&gt;</span>
                <span class="preprocessor">#include</span> <span class="string">&lt;string&gt;</span>
                <span class="preprocessor">#include</span> <span class="string">&lt;functional&gt;</span>
                <span class="preprocessor">#include</span> <span class="string">&lt;map&gt;</span>
                <span class="preprocessor">#include</span> <span class="string">&lt;set&gt;</span>
                <span class="preprocessor">#include</span> <span class="string">&lt;queue&gt;</span>
                
                <span class="keyword">using</span> <span class="keyword">namespace</span> std;
                
                <span class="keyword">struct</span> <span class="type">Edge</span> {
                    <span class="type">string</span> src, dest;
                    <span class="type">int</span> weight;
                };
                
                <span class="keyword">struct</span> <span class="type">Situation</span> {
                    <span class="type">string</span> description;
                    <span class="type">int</span> intensity;
                };
                
                <span class="keyword">class</span> <span class="type">Graph</span> {
                    <span class="type">vector</span>&lt;<span class="type">string</span>&gt; vertices;
                    <span class="type">vector</span>&lt;<span class="type">Edge</span>&gt; edges;
                    <span class="type">set</span>&lt;<span class="type">pair</span>&lt;<span class="type">string</span>, <span class="type">string</span>&gt;&gt; mstEdges;
                
                <span class="keyword">public</span>:
                    <span class="keyword">void</span> <span class="function">addVertex</span>(<span class="keyword">const</span> <span class="type">string</span>& vertex) {
                        vertices.push_back(vertex);
                    }
                
                    <span class="keyword">void</span> <span class="function">addEdge</span>(<span class="keyword">const</span> <span class="type">string</span>& src, <span class="keyword">const</span> <span class="type">string</span>& dest, <span class="type">int</span> weight) {
                        edges.push_back({src, dest, weight});
                    }
                
                    <span class="type">int</span> <span class="function">getVertexIndex</span>(<span class="keyword">const</span> <span class="type">string</span>& vertex) <span class="keyword">const</span> {
                        <span class="keyword">for</span> (<span class="type">int</span> i = 0; i &lt; vertices.size(); ++i) {
                            <span class="keyword">if</span> (vertices[i] == vertex) {
                                <span class="keyword">return</span> i;
                            }
                        }
                        <span class="keyword">return</span> -1;
                    }
                
                    <span class="type">pair</span>&lt;<span class="type">vector</span>&lt;<span class="type">string</span>&gt;, <span class="type">int</span>&gt; <span class="function">bellmanFordWithPath</span>(<span class="keyword">const</span> <span class="type">string</span>& src, <span class="keyword">const</span> <span class="type">string</span>& dest, <span class="type">bool</span> blockBF = <span class="keyword">false</span>) {
                        <span class="type">int</span> V = vertices.size();
                        <span class="type">int</span> srcIndex = <span class="function">getVertexIndex</span>(src);
                        <span class="type">int</span> destIndex = <span class="function">getVertexIndex</span>(dest);
                
                        <span class="keyword">if</span> (srcIndex == -1 || destIndex == -1) {
                            <span class="keyword">return</span> {{}, -1};
                        }
                
                        <span class="type">vector</span>&lt;<span class="type">int</span>&gt; dist(V, INT_MAX);
                        <span class="type">vector</span>&lt;<span class="type">int</span>&gt; prev(V, -1);
                        dist[srcIndex] = 0;
                
                        <span class="keyword">for</span> (<span class="type">int</span> i = 1; i &lt;= V - 1; ++i) {
                            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>& edge : edges) {
                                <span class="keyword">if</span> (blockBF && edge.src == <span class="string">"B"</span> && edge.dest == <span class="string">"F"</span>) <span class="keyword">continue</span>;
                
                                <span class="type">int</span> u = <span class="function">getVertexIndex</span>(edge.src);
                                <span class="type">int</span> v = <span class="function">getVertexIndex</span>(edge.dest);
                                <span class="type">int</span> weight = edge.weight;
                
                                <span class="keyword">if</span> (dist[u] != INT_MAX && dist[u] + weight &lt; dist[v]) {
                                    dist[v] = dist[u] + weight;
                                    prev[v] = u;
                                }
                            }
                        }
                
                        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>& edge : edges) {
                            <span class="type">int</span> u = <span class="function">getVertexIndex</span>(edge.src);
                            <span class="type">int</span> v = <span class="function">getVertexIndex</span>(edge.dest);
                            <span class="type">int</span> weight = edge.weight;
                            <span class="keyword">if</span> (dist[u] != INT_MAX && dist[u] + weight &lt; dist[v]) {
                                <span class="comment">// Negative cycle detected</span>
                                <span class="keyword">return</span> {{}, -2};
                            }
                        }
                
                        <span class="type">vector</span>&lt;<span class="type">string</span>&gt; path;
                        <span class="type">int</span> current = destIndex;
                        <span class="keyword">while</span> (current != -1) {
                            path.push_back(vertices[current]);
                            current = prev[current];
                        }
                        <span class="function">reverse</span>(path.begin(), path.end());
                
                        <span class="keyword">return</span> {path, dist[destIndex]};
                    }
                };
                            </pre>
                            <a href="https://github.com/PavanNagesh/pavanrepo/blob/main/BC-1.cpp" class="view-code-button">View Full Code</a>
                        </div>
                        <a href="buscase2.html"> <button>Next Business Case</button> </a>
                    </div>
                </body>
                </html>
